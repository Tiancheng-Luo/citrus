<!DOCTYPE html>

<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Citrus ~ Syntax</title>
    <link rel="stylesheet" type="text/css" media="all" href="css/style.css">
    <meta name="description" content="Parsing Expressions for Ruby">
    <meta name="keywords" content="Ruby, PEG, parsing expression grammar">
    <meta name="viewport" content="width=800">
</head>

<body>
    <div id="wrapper">
        <ul id="nav">
            <li class="title"><a href="index.html">citrus</a></li>
            <li class="separator"></li>
            <li><a href="background.html">background</a></li>
            <li><a href="syntax.html" class="selected">syntax</a></li>
            <li><a href="example.html">example</a></li>
            <li><a href="testing.html">testing</a></li>
            <li><a href="extras.html">extras</a></li>
            <li><a href="links.html">links</a></li>
            <li><a href="http://github.com/mjijackson/citrus">code</a></li>
            <li><a href="http://github.com/mjijackson/citrus/issues">issues</a></li>
            <li><a href="api/index.html">api</a></li>
        </ul>
        <div id="body-wrapper">
          <div id="body">
              <h1>Syntax</h1>

<p>The most straightforward way to compose a Citrus grammar is to use Citrus' own
custom grammar syntax. This syntax borrows heavily from Ruby, so it should
already be familiar to Ruby programmers.</p>

<h2>Terminals</h2>

<p>Terminals may be represented by a string or a regular expression. Both follow
the same rules as Ruby string and regular expression literals.</p>

<pre><code>'abc'         # match "abc"
"abc\n"       # match "abc\n"
/abc/i        # match "abc" in any case
/\xFF/        # match "\xFF"
</code></pre>

<p>Character classes and the dot (match anything) symbol are supported as well for
compatibility with other parsing expression implementations.</p>

<pre><code>[a-z0-9]      # match any lowercase letter or digit
[\x00-\xFF]   # match any octet
.             # match any single character, including new lines
</code></pre>

<p>Also, strings may use backticks instead of quotes to indicate that they should
match in a case-insensitive manner.</p>

<pre><code>`abc`         # match "abc" in any case
</code></pre>

<p>Besides case sensitivity, case-insensitive strings have the same behavior as
double quoted strings.</p>

<p>See <a href="api/classes/Citrus/Terminal.html">Terminal</a> and
<a href="api/classes/Citrus/StringTerminal.html">StringTerminal</a> for more information.</p>

<h2>Repetition</h2>

<p>Quantifiers may be used after any expression to specify a number of times it
must match. The universal form of a quantifier is <code>N*M</code> where <code>N</code> is the minimum
and <code>M</code> is the maximum number of times the expression may match.</p>

<pre><code>'abc'1*2      # match "abc" a minimum of one, maximum of two times
'abc'1*       # match "abc" at least once
'abc'*2       # match "abc" a maximum of twice
</code></pre>

<p>Additionally, the minimum and maximum may be omitted entirely to specify that an
expression may match zero or more times.</p>

<pre><code>'abc'*        # match "abc" zero or more times
</code></pre>

<p>The <code>+</code> and <code>?</code> operators are supported as well for the common cases of <code>1*</code> and
<code>*1</code> respectively.</p>

<pre><code>'abc'+        # match "abc" one or more times
'abc'?        # match "abc" zero or one time
</code></pre>

<p>See <a href="api/classes/Citrus/Repeat.html">Repeat</a> for more information.</p>

<h2>Lookahead</h2>

<p>Both positive and negative lookahead are supported in Citrus. Use the <code>&amp;</code> and
<code>!</code> operators to indicate that an expression either should or should not match.
In neither case is any input consumed.</p>

<pre><code>'a' &amp;'b'      # match an "a" that is followed by a "b"
'a' !'b'      # match an "a" that is not followed by a "b"
!'a' .        # match any character except for "a"
</code></pre>

<p>A special form of lookahead is also supported which will match any character
that does not match a given expression.</p>

<pre><code>~'a'          # match all characters until an "a"
~/xyz/        # match all characters until /xyz/ matches
</code></pre>

<p>When using this operator (the tilde), at least one character must be consumed
for the rule to succeed.</p>

<p>See <a href="api/classes/Citrus/AndPredicate.html">AndPredicate</a>,
<a href="api/classes/Citrus/NotPredicate.html">NotPredicate</a>, and
<a href="api/classes/Citrus/ButPredicate.html">ButPredicate</a> for more information.</p>

<h2>Sequences</h2>

<p>Sequences of expressions may be separated by a space to indicate that the rules
should match in that order.</p>

<pre><code>'a' 'b' 'c'   # match "a", then "b", then "c"
'a' [0-9]     # match "a", then a numeric digit
</code></pre>

<p>See <a href="api/classes/Citrus/Sequence.html">Sequence</a> for more information.</p>

<h2>Choices</h2>

<p>Ordered choice is indicated by a vertical bar that separates two expressions.
When using choice, each expression is tried in order. When one matches, the
rule returns the match immediately without trying the remaining rules.</p>

<pre><code>'a' | 'b'       # match "a" or "b"
'a' 'b' | 'c'   # match "a" then "b" (in sequence), or "c"
</code></pre>

<p>It is important to note when using ordered choice that any operator binds more
tightly than the vertical bar. A full chart of operators and their respective
levels of precedence is below.</p>

<p>See <a href="api/classes/Citrus/Choice.html">Choice</a> for more information.</p>

<h2>Labels</h2>

<p>Match objects may be referred to by a different name than the rule that
originally generated them. Labels are added by placing the label and a colon
immediately preceding any expression.</p>

<pre><code>chars:/[a-z]+/  # the characters matched by the regular expression
                # may be referred to as "chars" in an extension
                # method
</code></pre>

<h2>Extensions</h2>

<p>Extensions may be specified using either &ldquo;module&rdquo; or &ldquo;block&rdquo; syntax. When using
module syntax, specify the name of a module that is used to extend match objects
in between less than and greater than symbols.</p>

<pre><code>[a-z0-9]5*9 &lt;CouponCode&gt;  # match a string that consists of any lower
                          # cased letter or digit between 5 and 9
                          # times and extend the match with the
                          # CouponCode module
</code></pre>

<p>Additionally, extensions may be specified inline using curly braces. When using
this method, the code inside the curly braces may be invoked by calling the
<code>value</code> method on the match object.</p>

<pre><code>[0-9] { to_i }        # match any digit and return its integer value when
                      # calling the #value method on the match object
</code></pre>

<p>Note that when using the inline block method you may also specify arguments in
between vertical bars immediately following the opening curly brace, just like
in Ruby blocks.</p>

<h2>Super</h2>

<p>When including a grammar inside another, all rules in the child that have the
same name as a rule in the parent also have access to the <code>super</code> keyword to
invoke the parent rule.</p>

<pre><code>grammar Number
  rule number
    [0-9]+
  end
end

grammar FloatingPoint
  include Number

  rule number
    super ('.' super)?
  end
end
</code></pre>

<p>In the example above, the <code>FloatingPoint</code> grammar includes <code>Number</code>. Both have a
rule named <code>number</code>, so <code>FloatingPoint#number</code> has access to <code>Number#number</code> by
means of using <code>super</code>.</p>

<p>See <a href="api/classes/Citrus/Super.html">Super</a> for more information.</p>

<h2>Precedence</h2>

<p>The following table contains a list of all Citrus symbols and operators and
their precedence. A higher precedence indicates tighter binding.</p>

<table>
<thead>
<tr>
<th>Operator                  </th>
<th> Name                      </th>
<th> Precedence</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>''</code>                      </td>
<td> String (single quoted)    </td>
<td> 7</td>
</tr>
<tr>
<td><code>""</code>                      </td>
<td> String (double quoted)    </td>
<td> 7</td>
</tr>
<tr>
<td><code>``</code>           </td>
<td> String (case insensitive) </td>
<td> 7</td>
</tr>
<tr>
<td><code>[]</code>                      </td>
<td> Character class           </td>
<td> 7</td>
</tr>
<tr>
<td><code>.</code>                       </td>
<td> Dot (any character)       </td>
<td> 7</td>
</tr>
<tr>
<td><code>//</code>                      </td>
<td> Regular expression        </td>
<td> 7</td>
</tr>
<tr>
<td><code>()</code>                      </td>
<td> Grouping                  </td>
<td> 7</td>
</tr>
<tr>
<td><code>*</code>                       </td>
<td> Repetition (arbitrary)    </td>
<td> 6</td>
</tr>
<tr>
<td><code>+</code>                       </td>
<td> Repetition (one or more)  </td>
<td> 6</td>
</tr>
<tr>
<td><code>?</code>                       </td>
<td> Repetition (zero or one)  </td>
<td> 6</td>
</tr>
<tr>
<td><code>&amp;</code>                       </td>
<td> And predicate             </td>
<td> 5</td>
</tr>
<tr>
<td><code>!</code>                       </td>
<td> Not predicate             </td>
<td> 5</td>
</tr>
<tr>
<td><code>~</code>                       </td>
<td> But predicate             </td>
<td> 5</td>
</tr>
<tr>
<td><code>&lt;&gt;</code>                      </td>
<td> Extension (module name)   </td>
<td> 4</td>
</tr>
<tr>
<td><code>{}</code>                      </td>
<td> Extension (literal)       </td>
<td> 4</td>
</tr>
<tr>
<td><code>:</code>                       </td>
<td> Label                     </td>
<td> 3</td>
</tr>
<tr>
<td><code>e1 e2</code>                   </td>
<td> Sequence                  </td>
<td> 2</td>
</tr>
<tr>
<td><code>e1 &#124; e2</code> </td>
<td> Ordered choice            </td>
<td> 1</td>
</tr>
</tbody>
</table>


<h2>Grouping</h2>

<p>As is common in many programming languages, parentheses may be used to override
the normal binding order of operators. In the following example parentheses are
used to make the vertical bar between <code>'b'</code> and <code>'c'</code> bind tighter than the
space between <code>'a'</code> and <code>'b'</code>.</p>

<pre><code>'a' ('b' | 'c')   # match "a", then "b" or "c"
</code></pre>

              <p class="copyright"><a href="license.html">Copyright</a> &copy; 2011 <a href="http://mjijackson.com/">Michael Jackson</a></p>
          </div>
        </div>
    </div>
</body>

</html>
