<!DOCTYPE html>

<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Citrus ~ Parsing Expressions for Ruby</title>
    <link rel="stylesheet" type="text/css" media="all" href="css/style.css">
    <meta name="description" content="Parsing Expressions for Ruby">
    <meta name="keywords" content="Ruby, PEG, parsing expression grammar">
    <meta name="viewport" content="width=800">
</head>

<body>
    <div id="wrapper">
        <ul id="nav">
            <li class="title"><a href="index.html">citrus</a></li>
            <li class="separator">~<span class="splat">âœ»</span>~</li>
            <li><a href="background.html">background</a></li>
            <li><a href="syntax.html">syntax</a></li>
            <li><a href="example.html">example</a></li>
            <li><a href="links.html">links</a></li>
            <li><a href="http://github.com/mjijackson/citrus">code</a></li>
            <li><a href="http://github.com/mjijackson/citrus/issues">issues</a></li>
            <li><a href="api/index.html">api</a></li>
        </ul>
        <div id="body">
            <h1>Syntax</h1>

<p>The most straightforward way to compose a Citrus grammar is to use Citrus' own
custom grammar syntax. This syntax borrows heavily from Ruby, so it should
already be familiar to Ruby programmers.</p>

<h2>Terminals</h2>

<p>Terminals may be represented by a string or a regular expression. Both follow
the same rules as Ruby string and regular expression literals.</p>

<pre><code>'abc'
"abc\n"
/\xFF/
</code></pre>

<p>Character classes and the dot (match anything) symbol are supported as well for
compatibility with other parsing expression implementations.</p>

<pre><code>[a-z0-9]      # match any lowercase letter or digit
[\x00-\xFF]   # match any octet
.             # match anything, even new lines
</code></pre>

<p>See <a href="api/classes/Citrus/Terminal.html">Terminal</a> for more information.</p>

<h2>Repetition</h2>

<p>Quantifiers may be used after any expression to specify a number of times it
must match. The universal form of a quantifier is N*M where N is the minimum and
M is the maximum number of times the expression may match.</p>

<pre><code>'abc'1*2      # match "abc" a minimum of one, maximum
              # of two times
'abc'1*       # match "abc" at least once
'abc'*2       # match "abc" a maximum of twice
</code></pre>

<p>The + and ? operators are supported as well for the common cases of 1<em> and </em>1
respectively.</p>

<pre><code>'abc'+        # match "abc" at least once
'abc'?        # match "abc" a maximum of once
</code></pre>

<p>See <a href="api/classes/Citrus/Repeat.html">Repeat</a> for more information.</p>

<h2>Lookahead</h2>

<p>Both positive and negative lookahead are supported in Citrus. Use the &amp; and !
operators to indicate that an expression either should or should not match. In
neither case is any input consumed.</p>

<pre><code>&amp;'a' 'b'      # match a "b" preceded by an "a"
!'a' 'b'      # match a "b" that is not preceded by an "a"
!'a' .        # match any character except for "a"
</code></pre>

<p>A special form of lookahead is also supported which will match any character
that does not match a given expression.</p>

<pre><code>~'a'          # match all characters until an "a"
~/xyz/        # match all characters until /xyz/ matches
</code></pre>

<p>See <a href="api/classes/Citrus/AndPredicate.html">AndPredicate</a>,
<a href="api/classes/Citrus/NotPredicate.html">NotPredicate</a>, and
<a href="api/classes/Citrus/ButPredicate.html">ButPredicate</a> for more information.</p>

<h2>Sequences</h2>

<p>Sequences of expressions may be separated by a space to indicate that the rules
should match in that order.</p>

<pre><code>'a' 'b' 'c'   # match "a", then "b", then "c"
'a' [0-9]     # match "a", then a numeric digit
</code></pre>

<p>See <a href="api/classes/Citrus/Sequence.html">Sequence</a> for more information.</p>

<h2>Choices</h2>

<p>Ordered choice is indicated by a vertical bar that separates two expressions.
Note that any operator binds more tightly than the bar.</p>

<pre><code>'a' | 'b'       # match "a" or "b"
'a' 'b' | 'c'   # match "a" then "b" (in sequence), or "c"
</code></pre>

<p>See <a href="api/classes/Citrus/Choice.html">Choice</a> for more information.</p>

<h2>Super</h2>

<p>When including a grammar inside another, all rules in the child that have the
same name as a rule in the parent also have access to the &ldquo;super&rdquo; keyword to
invoke the parent rule.</p>

<p>See <a href="api/classes/Citrus/Super.html">Super</a> for more information.</p>

<h2>Labels</h2>

<p>Match objects may be referred to by a different name than the rule that
originally generated them. Labels are created by placing the label and a colon
immediately preceding any expression.</p>

<pre><code>chars:/[a-z]+/  # the characters matched by the regular
                # expression may be referred to as "chars"
                # in a block method
</code></pre>

<p>See <a href="api/classes/Citrus/Label.html">Label</a> for more information.</p>

<h2>Precedence</h2>

<p>The following table contains a list of all Citrus operators and their
precedence. A higher precedence indicates tighter binding.</p>

<table>
<thead>
<tr>
<th>Operator                  </th>
<th> Name                      </th>
<th> Precedence</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>''</code>                      </td>
<td> String (single quoted)    </td>
<td> 6</td>
</tr>
<tr>
<td><code>""</code>                      </td>
<td> String (double quoted)    </td>
<td> 6</td>
</tr>
<tr>
<td><code>[]</code>                      </td>
<td> Character class           </td>
<td> 6</td>
</tr>
<tr>
<td><code>.</code>                       </td>
<td> Dot (any character)       </td>
<td> 6</td>
</tr>
<tr>
<td><code>//</code>                      </td>
<td> Regular expression        </td>
<td> 6</td>
</tr>
<tr>
<td><code>()</code>                      </td>
<td> Grouping                  </td>
<td> 6</td>
</tr>
<tr>
<td><code>*</code>                       </td>
<td> Repetition (arbitrary)    </td>
<td> 5</td>
</tr>
<tr>
<td><code>+</code>                       </td>
<td> Repetition (one or more)  </td>
<td> 5</td>
</tr>
<tr>
<td><code>?</code>                       </td>
<td> Repetition (zero or one)  </td>
<td> 5</td>
</tr>
<tr>
<td><code>&amp;</code>                       </td>
<td> And predicate             </td>
<td> 4</td>
</tr>
<tr>
<td><code>!</code>                       </td>
<td> Not predicate             </td>
<td> 4</td>
</tr>
<tr>
<td><code>~</code>                       </td>
<td> But predicate             </td>
<td> 4</td>
</tr>
<tr>
<td><code>:</code>                       </td>
<td> Label                     </td>
<td> 4</td>
</tr>
<tr>
<td><code>&lt;&gt;</code>                      </td>
<td> Extension (module name)   </td>
<td> 3</td>
</tr>
<tr>
<td><code>{}</code>                      </td>
<td> Extension (literal)       </td>
<td> 3</td>
</tr>
<tr>
<td><code>e1 e2</code>                   </td>
<td> Sequence                  </td>
<td> 2</td>
</tr>
<tr>
<td><code>e1 &#124; e2</code> </td>
<td> Ordered choice            </td>
<td> 1</td>
</tr>
</tbody>
</table>


            <p class="copyright"><a href="license.html">Copyright</a> &copy; 2010 <a href="http://mjijackson.com/">Michael Jackson</a></p>
        </div>
    </div>
</body>

</html>
