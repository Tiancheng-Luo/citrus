<!DOCTYPE html>

<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Citrus ~ Example</title>
    <link rel="stylesheet" type="text/css" media="all" href="css/style.css">
    <meta name="description" content="Parsing Expressions for Ruby">
    <meta name="keywords" content="Ruby, PEG, parsing expression grammar">
    <meta name="viewport" content="width=800">
</head>

<body>
    <div id="wrapper">
        <ul id="nav">
            <li class="title"><a href="index.html">citrus</a></li>
            <li class="separator"></li>
            <li><a href="background.html">background</a></li>
            <li><a href="syntax.html">syntax</a></li>
            <li><a href="example.html" class="selected">example</a></li>
            <li><a href="testing.html">testing</a></li>
            <li><a href="extras.html">extras</a></li>
            <li><a href="links.html">links</a></li>
            <li><a href="http://github.com/mjijackson/citrus">code</a></li>
            <li><a href="http://github.com/mjijackson/citrus/issues">issues</a></li>
            <li><a href="api/index.html">api</a></li>
        </ul>
        <div id="body-wrapper">
          <div id="body">
              <h1>Example</h1>

<p>Below is an example of a simple grammar that is able to parse strings of
integers separated by any amount of white space and a <code>+</code> symbol.</p>

<pre><code>grammar Addition
  rule additive
    number plus (additive | number)
  end

  rule number
    [0-9]+ space
  end

  rule plus
    '+' space
  end

  rule space
    [ \t]*
  end
end
</code></pre>

<p>Several things to note about the above example:</p>

<ul>
<li>Grammar and rule declarations end with the <code>end</code> keyword</li>
<li>A sequence of rules is created by separating expressions with a space</li>
<li>Likewise, ordered choice is represented with a vertical bar</li>
<li>Parentheses may be used to override the natural binding order</li>
<li>Rules may refer to other rules in their own definitions simply by using the
other rule&rsquo;s name</li>
<li>Any expression may be followed by a quantifier</li>
</ul>


<h2>Interpretation</h2>

<p>The grammar above is able to parse simple mathematical expressions such as &ldquo;1+2&rdquo;
and &ldquo;1 + 2+3&rdquo;, but it does not have enough semantic information to be able to
actually interpret these expressions.</p>

<p>At this point, when the grammar parses a string it generates a tree of
<a href="api/classes/Citrus/Match.html">Match</a> objects. Each match is created by a rule
and may itself be comprised of any number of submatches.</p>

<p>Submatches are created whenever a rule contains another rule. For example, in
the grammar above <code>number</code> matches a string of digits followed by white space.
Thus, a match generated by this rule will contain two submatches.</p>

<p>We can define a method inside a set of curly braces that will be used to extend
a particular rule&rsquo;s matches. This works in similar fashion to using Ruby&rsquo;s
blocks. Let&rsquo;s extend the <code>Addition</code> grammar using this technique.</p>

<pre><code>grammar Addition
  rule additive
    (number plus term:(additive | number)) {
      number.value + term.value
    }
  end

  rule number
    ([0-9]+ space) {
      to_i
    }
  end

  rule plus
    '+' space
  end

  rule space
    [ \t]*
  end
end
</code></pre>

<p>In this version of the grammar we have added two semantic blocks, one each for
the <code>additive</code> and <code>number</code> rules. These blocks contain code that we can
execute by calling <code>value</code> on match objects that result from those rules. It&rsquo;s
easiest to explain what is going on here by starting with the lowest level
block, which is defined within <code>number</code>.</p>

<p>Inside this block we see a call to another method, namely <code>to_i</code>. When called in
the context of a match object, methods that are not defined may be called on a
match&rsquo;s internal string object via <code>method_missing</code>. Thus, the call to <code>to_i</code>
should return the integer value of the match.</p>

<p>Similarly, matches created by <code>additive</code> will also have a <code>value</code> method. Notice
the use of the <code>term</code> label within the rule definition. This label allows the
match that is created by the choice between <code>additive</code> and <code>number</code> to be
retrieved using the <code>term</code> method. The value of an additive match is determined
to be the values of its <code>number</code> and <code>term</code> matches added together using Ruby&rsquo;s
addition operator.</p>

<p>Since <code>additive</code> is the first rule defined in the grammar, any match that
results from parsing a string with this grammar will have a <code>value</code> method that
can be used to recursively calculate the collective value of the entire match
tree.</p>

<p>To give it a try, save the code for the <code>Addition</code> grammar in a file called
addition.citrus. Next, assuming you have the Citrus
<a href="https://rubygems.org/gems/citrus">gem</a> installed, try the following sequence of
commands in a terminal.</p>

<pre><code>$ irb
&gt; require 'citrus'
 =&gt; true
&gt; Citrus.load 'addition'
 =&gt; [Addition]
&gt; m = Addition.parse '1 + 2 + 3'
 =&gt; #&lt;Citrus::Match ...
&gt; m.value
 =&gt; 6
</code></pre>

<p>Congratulations! You just ran your first piece of Citrus code.</p>

<p>One interesting thing to notice about the above sequence of commands is the
return value of <a href="api/classes/Citrus.html#M000003">Citrus#load</a>. When you use
<code>Citrus.load</code> to load a grammar file (and likewise
<a href="api/classes/Citrus.html#M000004">Citrus#eval</a> to evaluate a raw string of
grammar code), the return value is an array of all the grammars present in that
file.</p>

<p>Take a look at
<a href="http://github.com/mjijackson/citrus/blob/master/examples/calc.citrus">examples/calc.citrus</a>
for an example of a calculator that is able to parse and evaluate more complex
mathematical expressions.</p>

<h2>Additional Methods</h2>

<p>If you need more than just a <code>value</code> method on your match object, you can attach
additional methods as well. There are two ways to do this. The first lets you
define additional methods inline in your semantic block. This block will be used
to create a new Module using <a href="http://ruby-doc.org/core/classes/Module.html#M001682">Module#new</a>. Using the
<code>Addition</code> example above, we might refactor the <code>additive</code> rule to look like
this:</p>

<pre><code>rule additive
  (number plus term:(additive | number)) {
    def lhs
      number.value
    end

    def rhs
      term.value
    end

    def value
      lhs + rhs
    end
  }
end
</code></pre>

<p>Now, in addition to having a <code>value</code> method, matches that result from the
<code>additive</code> rule will have a <code>lhs</code> and a <code>rhs</code> method as well. Although not
particularly useful in this example, this technique can be useful when unit
testing more complex rules. For example, using this method you might make the
following assertions in a unit test:</p>

<pre><code>match = Addition.parse('1 + 4')
assert_equal(1, match.lhs)
assert_equal(4, match.rhs)
assert_equal(5, match.value)
</code></pre>

<p>If you would like to abstract away the code in a semantic block, simply create
a separate Ruby module (in another file) that contains the extension methods you
want and use the angle bracket notation to indicate that a rule should use that
module when extending matches.</p>

<p>To demonstrate this method with the above example, in a Ruby file you would
define the following module.</p>

<pre><code>module Additive
  def lhs
    number.value
  end

  def rhs
    term.value
  end

  def value
    lhs + rhs
  end
end
</code></pre>

<p>Then, in your Citrus grammar file the rule definition would look like this:</p>

<pre><code>  rule additive
    (number plus term:(additive | number)) &lt;Additive&gt;
  end
</code></pre>

<p>This method of defining extensions can help keep your grammar files cleaner.
However, you do need to make sure that your extension modules are already loaded
before using <code>Citrus.load</code> to load your grammar file.</p>

              <p class="copyright"><a href="license.html">Copyright</a> &copy; 2011 <a href="http://mjijackson.com/">Michael Jackson</a></p>
          </div>
        </div>
    </div>
</body>

</html>
