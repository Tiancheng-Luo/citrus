<!DOCTYPE html>

<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Citrus ~ Parsing Expressions for Ruby</title>
    <link rel="stylesheet" type="text/css" media="all" href="css/style.css">
    <meta name="description" content="Parsing Expressions for Ruby">
    <meta name="keywords" content="Ruby, PEG, parsing expression grammar">
    <meta name="viewport" content="width=800">
</head>

<body>
    <div id="wrapper">
        <ul id="nav">
            <li class="title"><a href="index.html">citrus</a></li>
            <li class="separator">~<span class="splat">âœ»</span>~</li>
            <li><a href="background.html">background</a></li>
            <li><a href="syntax.html">syntax</a></li>
            <li><a href="example.html">example</a></li>
            <li><a href="testing.html">testing</a></li>
            <li><a href="extras.html">extras</a></li>
            <li><a href="links.html">links</a></li>
            <li><a href="http://github.com/mjijackson/citrus">code</a></li>
            <li><a href="http://github.com/mjijackson/citrus/issues">issues</a></li>
            <li><a href="api/index.html">api</a></li>
        </ul>
        <div id="body">
            <h1>Example</h1>

<p>Below is an example of a simple grammar that is able to parse strings of
integers separated by any amount of white space and a <code>+</code> symbol.</p>

<pre><code>grammar Addition
  rule additive
    number plus (additive | number)
  end

  rule number
    [0-9]+ space
  end

  rule plus
    '+' space
  end

  rule space
    [ \t]*
  end
end
</code></pre>

<p>Several things to note about the above example:</p>

<ul>
<li>Grammar and rule declarations end with the <code>end</code> keyword</li>
<li>A Sequence of rules is created by separating expressions with a space</li>
<li>Likewise, ordered choice is represented with a vertical bar</li>
<li>Parentheses may be used to override the natural binding order</li>
<li>Rules may refer to other rules in their own definitions simply by using the
other rule&rsquo;s name</li>
<li>Any expression may be followed by a quantifier</li>
</ul>


<h2>Interpretation</h2>

<p>The grammar above is able to parse simple mathematical expressions such as &ldquo;1+2&rdquo;
and &ldquo;1 + 2+3&rdquo;, but it does not have enough semantic information to be able to
actually interpret these expressions.</p>

<p>At this point, when the grammar parses a string it generates a tree of
<a href="api/classes/Citrus/Match.html">Match</a> objects. Each match is created by a rule
and may itself be comprised of any number of submatches.</p>

<p>Submatches are created whenever a rule contains another rule. For example, in
the grammar above <code>number</code> matches a string of digits followed by white space.
Thus, a match generated by this rule will contain two submatches.</p>

<p>We can define methods inside a set of curly braces that will be used to extend
matches when they are created. This works in similar fashion to using Ruby&rsquo;s
blocks. Let&rsquo;s extend the <code>Addition</code> grammar using this technique.</p>

<pre><code>grammar Addition
  rule additive
    (number plus term:(additive | number)) {
      def value
        number.value + term.value
      end
    }
  end

  rule number
    ([0-9]+ space) {
      def value
        strip.to_i
      end
    }
  end

  rule plus
    '+' space
  end

  rule space
    [ \t]*
  end
end
</code></pre>

<p>In this version of the grammar we have added two semantic blocks, one each for
the additive and number rules. These blocks contain methods that will be present
on all match objects that result from matches of those particular rules. It&rsquo;s
easiest to explain what is going on here by starting with the lowest level
block, which is defined within the number rule.</p>

<p>The semantic block associated with the number rule defines one method, <code>value</code>.
Inside this method, we can see that the value of a number match is determined to
be its text value, stripped of white space and converted to an integer.
<a href="background.html">Remember</a> that matches are simply strings, so the <code>strip</code>
method in this case is actually
<a href="http://ruby-doc.org/core/classes/String.html#M000820">String#strip</a>.</p>

<p>The <code>additive</code> rule also extends its matches with a <code>value</code> method. Notice the
use of the <code>term</code> label within the rule definition. This label allows the match
that is created by either the additive or the number rule to be retrieved using
the <code>term</code> label. The value of an additive is determined to be the values of its
<code>number</code> and <code>term</code> matches added together using Ruby&rsquo;s addition operator.</p>

<p>Since additive is the first rule defined in the grammar, any match that results
from parsing a string with this grammar will have a <code>value</code> method that can be
used to recursively calculate the collective value of the entire match tree.</p>

<p>To give it a try, save the code for the <code>Addition</code> grammar in a file called
addition.citrus. Next, assuming you have the Citrus
<a href="https://rubygems.org/gems/citrus">gem</a> installed, try the following sequence of
commands in a terminal.</p>

<pre><code>$ irb
&gt; require 'citrus'
 =&gt; true
&gt; Citrus.load 'addition'
 =&gt; [Addition]
&gt; m = Addition.parse '1 + 2 + 3'
 =&gt; #&lt;Citrus::Match ...
&gt; m.value
 =&gt; 6
</code></pre>

<p>Congratulations! You just ran your first piece of Citrus code.</p>

<p>One interesting thing to notice about the above sequence of commands is the
return value of <a href="api/classes/Citrus.html#M000003">Citrus#load</a>. When you use
<code>Citrus.load</code> to load a grammar file (and likewise
<a href="api/classes/Citrus.html#M000004">Citrus#eval</a> to evaluate a raw string of
grammar code), the return value is an array of all the grammars present in that
file.</p>

<p>Take a look at
<a href="http://github.com/mjijackson/citrus/blob/master/examples/calc.citrus">examples/calc.citrus</a>
for an example of a calculator that is able to parse and evaluate more complex
mathematical expressions.</p>

<h2>Implicit Value</h2>

<p>It is very common for a grammar to only have one interpretation for a given
symbol. For this reason, you may find yourself writing a <code>value</code> method for
every rule in your grammar. Because this can be tedious, Citrus allows you to
omit defining such a method if you choose. For example, the <code>additive</code> and
<code>number</code> rules from the simple calculator example above could also be written
as:</p>

<pre><code>rule additive
  (number plus term:(additive | number)) {
    number.value + term.value
  }
end

rule number
  ([0-9]+ space) {
    strip.to_i
  }
end
</code></pre>

<p>Since no method name is explicitly specified in the semantic blocks, they may be
called using the <code>value</code> method.</p>

            <p class="copyright"><a href="license.html">Copyright</a> &copy; 2010 <a href="http://mjijackson.com/">Michael Jackson</a></p>
        </div>
    </div>
</body>

</html>
