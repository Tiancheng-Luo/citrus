<!DOCTYPE html>

<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Citrus ~ Parsing Expressions for Ruby</title>
    <link rel="stylesheet" type="text/css" media="all" href="css/style.css">
    <meta name="description" content="Parsing Expressions for Ruby">
    <meta name="keywords" content="Ruby, PEG, parsing expression grammar">
    <meta name="viewport" content="width=800">
</head>

<body>
    <div id="wrapper">
        <ul id="nav">
            <li class="title"><a href="index.html">citrus</a></li>
            <li class="separator">~<span class="splat">âœ»</span>~</li>
            <li><a href="background.html">background</a></li>
            <li><a href="syntax.html">syntax</a></li>
            <li><a href="example.html">example</a></li>
            <li><a href="http://github.com/mjijackson/citrus">code</a></li>
            <li><a href="http://github.com/mjijackson/citrus/issues">issues</a></li>
            <li><a href="api/index.html">api</a></li>
        </ul>
        <div id="body">
            <h1>Example</h1>
<p>
Below is an example of a simple grammar that is able to parse strings of
integers separated by any amount of white space and a <tt>+</tt> symbol.
</p>
<pre>
  grammar Addition
    rule additive
      number plus (additive | number)
    end

    rule number
      [0-9]+ space
    end

    rule plus
      '+' space
    end

    rule space
      [ \t]*
    end
  end
</pre>
<p>
Several things to note about the above example:
</p>
<ul>
<li><p>
Grammar and rule declarations end with the <tt>end</tt> keyword
</p>
</li>
<li><p>
A Sequence of rules is created by separating expressions with a space
</p>
</li>
<li><p>
Likewise, ordered choice is represented with a vertical bar
</p>
</li>
<li><p>
Parentheses may be used to override the natural binding order
</p>
</li>
<li><p>
Rules may refer to other rules in their own definitions simply by using the
other rule&#8217;s name
</p>
</li>
<li><p>
Any expression may be followed by a quantifier
</p>
</li>
</ul>
<h2>Interpretation</h2>
<p>
The grammar above is able to parse simple mathematical expressions such as
&#8220;1+2&#8221; and &#8220;1 + 2+3&#8221;, but it does not have enough
semantic information to be able to actually interpret these expressions.
</p>
<p>
At this point, when the grammar parses a string it generates a tree of <a
href="api/classes/Citrus/Match.html">Match</a> objects. Each match is
created by a rule. A match will know what text it contains, its offset in
the original input, and what submatches it contains.
</p>
<p>
Submatches are created whenever a rule contains another rule. For example,
in the grammar above the number rule matches a string of digits followed by
white space. Thus, a match generated by the number rule will contain two
submatches.
</p>
<p>
We can use Ruby&#8217;s block syntax to create a module that will be
attached to these matches when they are created and is used to lazily
extend them when we want to interpret them. The following example shows one
way to do this.
</p>
<pre>
  grammar Addition
    rule additive
      (number plus term) {
        def value
          number.value + term.value
        end
      }
    end

    rule term
      (additive | number) {
        def value
          first.value
        end
      }
    end

    rule number
      ([0-9]+ space) {
        def value
          text.strip.to_i
        end
      }
    end

    rule plus
      '+' space
    end

    rule space
      [ \t]*
    end
  end
</pre>
<p>
In this version of the grammar the additive rule has been refactored to use
the term rule. This makes it a little cleaner to define our semantic
blocks. It&#8217;s easiest to explain what is going on here by starting
with the lowest level block, which is defined within the number rule.
</p>
<p>
The semantic block associated with the number rule defines one method,
value. This method will be present on all matches that result from this
rule. Inside this method, we can see that the value of a number match is
determined to be its text value, stripped of white space and converted to
an integer.
</p>
<p>
Similarly, the block that is applied to term matches also defines a value
method. However, this method works a bit differently. Since a term matches
an additive or a number a term match will contain one submatch, the match
that resulted from either additive or number. The first method retrieves
the first submatch. So, the value of a term is determined to be the value
of its first submatch.
</p>
<p>
Finally, the additive rule also extends its matches with a value method.
Here, the value of an additive is determined to be the values of its number
and term matches added together using Ruby&#8217;s addition operator.
</p>
<p>
Since additive is the first rule defined in the grammar, any match that
results from parsing a string with this grammar will have a value method
that can be used to recursively calculate the collective value of the
entire match tree.
</p>
<p>
To give it a try, save the code for the Addition grammar in a file called
addition.citrus. Next, assuming you have the Citrus gem installed, try the
following sequence of commands in a terminal.
</p>
<pre>
  $ irb
  &gt; require 'citrus'
   =&gt; true
  &gt; Citrus.load 'addition'
   =&gt; [Addition]
  &gt; m = Addition.parse '1 + 2 + 3'
   =&gt; #&lt;Citrus::Match ...
  &gt; m.value
   =&gt; 6
</pre>
<p>
Congratulations! You just ran your first piece of Citrus code.
</p>
<p>
Take a look at <a
href="http://github.com/mjijackson/citrus/blob/master/examples/calc.citrus">examples/calc.citrus</a>
for an example of a calculator that is able to parse and evaluate more
complex mathematical expressions.
</p>

            <p class="copyright"><a href="license.html">Copyright</a> &copy; 2010 <a href="http://mjijackson.com/">Michael Jackson</a></p>
        </div>
    </div>
</body>

</html>
